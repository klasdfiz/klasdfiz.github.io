<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[C++基础_0x00]]></title>
      <url>%2F2016%2F11%2F17%2FC-%E5%9F%BA%E7%A1%80-0x00%2F</url>
      <content type="text"><![CDATA[今天在网上看到有人非常耐心地对c++primer一书从第一章开始一节一节地写读书笔记，着实令我非常佩服。于是我就想着，也该是时候把平时记的一些东西归纳整理下，把它们归类存电子档起来，这样以后就不用翻阅纸质文档了。 运算符 算术运算符：* - + / 关系运算符：&lt; &gt; == != &gt;= &lt;= 逻辑运算符：&amp;&amp; || ！ 位运算符： &lt;&lt; &gt;&gt; ~ | &amp; ^ 赋值运算符：= 域运算符：:: 模运算符：% 条件运算符：? : 逗号运算符：， （e.g. a=3*5, a*4; //a为60） 指针运算符：* &amp; 求字节运算符：sizeof 强制类型转换运算符：（类型） 分量运算符：. -&gt; （应用于类、结构体中） 下标运算符：[ ] 函数调用运算符：（变量） 优先级关系 L1：( ) [ ] -&gt; . :: 右++ 右– L2：! ~ 左++ 左– - + * &amp; (type) sizeof L3：-&gt; . （e.g. ptr-&gt;*var=24; obj* var; L4：* / % L5：+ - L6：&lt;&lt; &gt;&gt; L7：&lt; &gt; &lt;= &gt;= L8：== != L9：&amp; L10：^ L11：| L12：&amp;&amp; L13：|| L14：? : L15：= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= L16：， 联合体 union 123456union Name&#123; type1 member1; type2 member2; ...&#125;; 成员具有相同的内存地址，对某个成员赋值，将会覆盖之前成员的值，使之消失。（这也是其与结构体的区别） 在任意时刻，union只能有一个成员存在值。 无名联合体通常用于结构体/类的成员。(就是没有Name的联合体) e.g. 类 Class 构造函数constructor（有默认的） 作用：对对象进行初始化，在对象被创建时由编译器自动调用。 函数名与类名相同，没有返回值。 拷贝构造函数copy constructor（有默认的） 形参为本类对象的引用，作用是用一个已存在的对象去初始化另一个新的对象，具体即为完成对象的克隆。形如：类名 (类名 &amp;对象名) 被调用的情况（条件）： 用一个对象去初始化另一个对象。 Point a(b) 某函数的形参为类的对象时，在进行形参与实参结合时。void f(Point a) 某函数的返回值为类的对象时，在返回调用的时候。Point f(int x) ps: 编译器会在调用函数处创建一个临时的无名对象，其生命周期仅存在于如Point A = f(); 此语句中。 类的成员函数 原型声明要写在类体中，而具体实现一般是要写在类之外的。返回类型 类名::函数名(参数列表) {} 内联成员函数inline 显式：在函数体实现时，在返回值的类型前加inline 隐式：直接将函数体放于类体内。 针对一些功能简单、规模较小、使用频繁的函数，可以设计为内联函数，它会在程序的编译时期将函数体放到每一个调用处。 inline只表示对编译器发出一个请求，但编译器并不一定承诺将其作为内联，同时，没有用inline修饰的函数也可能被编译成内联。 析构函数destructor (有默认的) 在对象的生存期即将结束时被自动调用，不接受任何参数~类名(){} 类的组合 各类的构造函数调用次序： 1）先调用内嵌对象的构造函数，如果内嵌了多个类，则按它们在类中定义的顺序来调用； 2）再调用本类的构造函数。 析构函数的调用顺序则与构造函数完全相反。 组合类构造函数定义的一般形式： 类名::类名(形参表):内嵌对象1(形参表), 内嵌对象2(形参表)... {} 此构造函数组合类初始化方法可应用于一般变量，如Circle::Circle(float r) : R(r){} 为组合类编写拷贝构造函数时，需要为内嵌成员对象传递参数。 类的前向引用声明 类的组合可能会相互依赖，此时便需要前向引用声明，否则编译不会通过，但可以声明指针，不能是对象。123class B;class A&#123;void f(B b)&#125;; //声明了对象，则必须前向声明class B&#123;void g(A a)&#125;; 类中的数据共享机制 类的静态成员-&gt; 解决同一个类不同对象之间数据与函数共享问题。 静态数据成员 一个类的所有对象只有一份拷贝； 通过类名::属性名来访问，在所有函数外部进行初始化。 静态函数成员 可以直接访问该类的静态数据和函数成员； 如果要访问非静态数据成员，则必须进行参数传递来得到对象，再由对象来访问； 非静态函数也可以访问静态成员，但需要用非内联函数，同时函数体要与静态成员处于同一个源文件中。 友元 friend-&gt; 不同类的成员函数之间或成员函数与普通函数之间的数据共享机制 友元函数 在类中用friend修饰的非成员函数；（该函数在类外的实现不必加friend 友元函数可以是另一个类的成员函数； 可以访问该类的private, protected成员； 通过类的对象来访问对象成员 友元类 12345class B&#123; friend class A; ...&#125;; A的所有成员函数均为B的友元函数，可以访问B类的所有成员； 友元关系不能传递、继承，同时是单向的。 References 由于我是早些年先整理出的纸质文档，参考文献较多且当时没有标注，若构成侵权请在底下留言，我会进行删除。今天先整这么多了，goodnight:)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用GTK+写点儿界面]]></title>
      <url>%2F2016%2F11%2F17%2F%E7%94%A8GTK-%E5%86%99%E7%82%B9%E5%84%BF%E7%95%8C%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[最近需要在ubuntu上写一个界面，找了一圈还是用GTK+来写吧，毕竟跟C语系是同宗的，结合起来比较顺手。这里列一些常用的API吧。12345678gtk_init(&amp;argc, &amp;argv);window = gtk_window_new(GTK_WINDOW_TOPLEVEL);gtk_window_set_title(GTK_WINDOW(window), "xxx"); //titlegtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER); //set centergtk_widget_set_usize(GTK_WIDGET(window), x, y); //大小gtk_window_set_resizable(GTK_WINDOW(window), FALSE); //固定界面大小，不能拖拽g_signal_connect(要处理的部件, "动作", G_CALLBACK(要响应的部件), (gpointer)参数部件可null);//如果“要处理的部件”对应多个“要响应的部件”，则直接添加多个g_signal_connect函数即可 额，又水了一篇，下次尽量整干点的~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[来点儿闲话]]></title>
      <url>%2F2016%2F11%2F17%2F%E6%9D%A5%E7%82%B9%E5%84%BF%E9%97%B2%E8%AF%9D%2F</url>
      <content type="text"><![CDATA[今年双十一没买东西，因为要毕业了，本来东西就很多带不走了，不想再添置了。然后前两天给自己买了这个域名，果然还是搞IT的么，哈哈。域名买来后就各种折腾啊，自己在这块儿之前没经验，很菜，慢慢地可算按照网上的前辈步子逐步把它给搞定了。搞了google与百度的收录，google很快一天内就好了，果然对个人站点很友好。百度的话，嗯。因为github屏蔽了baiducrawler，而且对国内网络不是很友好，所以我又把这个站点同步到coding。然后站点的baidusitemap生成的地址又是github的，这个就比较尴尬了，这问题还是先搁着吧，反正baidu还没给我收录。 感觉买了域名后，更加坚定写博客的心吧，之前在csdn上一直断断续续的，这个不好得改。关于写博客我就不再强行安利了，如人饮水冷暖自知，甭管有没有人看，于我而言主要还可以自己查阅之前遇到的坑，好习惯得坚持，对吧：）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql-proxy installation]]></title>
      <url>%2F2016%2F11%2F10%2Fmysql-proxy-installation%2F</url>
      <content type="text"><![CDATA[os: ubuntu 13.04 amd64 1) install the lua env.1sudo apt-get install liblua5.1-0-dev 2) install the mysql-proxy1sudo apt-get install mysql-proxy 3) start mysql-proxy1mysql-proxy --proxy-address=your_ip:your_port --proxy-backend-addresses=your_mysql_server_addresses --proxy-lua-script=/usr/share/mysql-proxy/rw-splitting.lua --admin-username=your_name --admin-password=your_password --admin-lua-script=/usr/share/mysql-proxy/admin.lua ========== update: 今天仓促地post了这篇，然后我的站点就挂掉了，不清楚是什么问题，调了几个小时依旧不能解决，考虑到之前博文有备份，索性rebuild了整个bog，我这种解法也是蛮暴力的+_+]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ubuntu低版本更新源]]></title>
      <url>%2F2016%2F11%2F02%2FUbuntu%E4%BD%8E%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E6%BA%90%2F</url>
      <content type="text"><![CDATA[由于很多原型系统都是在低版本的linux上研发的，所以经常需要用到这些老古董，但是很多源都已经不支持在线安装和更新了，因此google到了一份支持老版本的更新源，备份下。 12345678910111213141516/etc/apt/sources.listdeb http://old-releases.ubuntu.com/ubuntu/ raring main universe restricted multiversedeb-src http://old-releases.ubuntu.com/ubuntu/ raring main universe restricted multiversedeb http://old-releases.ubuntu.com/ubuntu/ raring-security main universe restricted multiversedeb-src http://old-releases.ubuntu.com/ubuntu/ raring-security main universe restricted multiversedeb http://old-releases.ubuntu.com/ubuntu/ raring-updates main universe restricted multiversedeb-src http://old-releases.ubuntu.com/ubuntu/ raring-updates main universe restricted multiversedeb http://old-releases.ubuntu.com/ubuntu/ raring-backports main restricted universe multiversedeb-src http://old-releases.ubuntu.com/ubuntu/ raring-backports main restricted universe multiversedeb http://old-releases.ubuntu.com/ubuntu/ raring-proposed main restricted universe multiversedeb-src http://old-releases.ubuntu.com/ubuntu/ raring-proposed main restricted universe multiverse]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello Blogs]]></title>
      <url>%2F2016%2F09%2F15%2FHello-Blogs%2F</url>
      <content type="text"><![CDATA[Hexo+github博客搭建成功，以后就往这里发博文了^_^，开博先来一篇搭建的过程，记录下方便以后查阅。PS：之前的博客地址是http://blog.csdn.net/scanf5288 工具 node.js git github账户 duoshuo账户 macOS 安装Hexohexo是一个基于node.js的简便、功能强劲的博客框架。Nodejs的安装是傻瓜式地点下一步即可。安装后，其包管理器npm也会一并安好。 1）打开terminal，键入命令1sudo npm install -g hexo-cli --no-optional 2）选择在自己方便管理的地方，创建博客的根目录文件夹，如我是在~/Documents/下创建了一个Blog的文件夹，统一管理。 3）进入根目录，执行两条命令hexo init与npm install 至此，hexo已安装完毕，这样我们就已经可以再本地写博文了。 关联GitHub Pages接下来我们的工作是把本地的博文部署到gitpage上，以供他人阅览，总不能自己写的博客仅给自己看吧^_^ 本节的首要前提是你的电脑需要有自己仓库的push权限，权限的配置只需到github个人设置里添加本机的ssh key即可，这个网上有很多教程就不进行赘述了。 1）先在github上new一个仓库，仓库名必须是“github账户名.github.io”。以后它就是你个人博客的地址了。 2）安装git部署插件，执行1npm install hexo-deployer-git --save 3）配置根目录下的站点配置文件_config.yml。在文件的下方，修改1234deploy: type: git repo: https://github.com/yourgithub/yourgithub.github.io.git branch: master 注意需要有branch属性，有的教程里面说不需要，但经过我自己实践是需要的。至此，关联gitpage完毕。 关于部署部署之前，肯定先是准备自己的博文，执行1hexo new "article_name" 就会在/source/_posts/下生成article_name.md文件，支持MarkDown语法，然后就可以欢快地进行书写了。 在真正部署之前，我一般喜欢在本地预览下效果，执行12hexo g //hexo generate 生成页面hexo s //hexo server 本地服务器启动 然后打开浏览器输入localhost:4000即可访问。 到了真正部署就容易了，执行1hexo d //hexo deploy 部署页面 随后浏览 https://yourgithub.github.io 即可，以后它就是你的站点了。当然它只是个二级域名，你还可以购买自己的域名，这样就更利于博客的推广了：） 还有一条hexo clean，我一般是在执行修改themes等较大变动时执行的，注意是在hexo g与hexo d之前。 关于主题themes本博客是用的NexT主题，简洁大方，安装很容易，在博客根目录下 1）先clone next的主题1git clone https://github.com/iissnan/hexo-theme-next themes/next 2）修改站点配置文件_config.yml。找到theme:属性，修改为next即可。 duoshuo评论模块有了博文，自然需要评论区好让看客发言，本博客采用的是多说评论系统，关联新浪微博。 1）登录duoshuo官网，创建站点，记住自己的域名信息。 2）修改主题文件夹下的配置文件/themes/next/_config.yml，注意不是站点配置文件！修改：12# Duoshuo ShortNameduoshuo_shortname: yourduoshuo 3）最后hexo g和hexo d就行了。 关于更多评论区的设置，上duoshuo官网个人页面管理里就有了。 文章分享功能当我们有了duoshuo账户后，只需要一句配置就可以开启分享功能了~修改主题配置文件/themes/next/_config.yml的duoshuo_share12# Shareduoshuo_share: true 站内搜索1）安装hexo-generator-searchdb插件，在博客根目录下执行1npm install hexo-generator-searchdb --save 2）修改站点的配置文件_config.yml，新增search项：12345search: path: search.xml field: post format: html limit: 10000 文章阅读量统计这里用的是LearnCloud，配置过程参考链接10已经描述的非常清楚了，相信诸君能看懂。 插件推荐这个是看网上前人推荐的，个人感觉挺好用的： 支持RSS：npm install hexo-generator-feed –save 生成站点地图：npm install hexo-generator-sitemap –save 生成百度站点地图：npm install hexo-generator-baidu-sitemap –save HTML压缩：npm install hexo-html-minifier –save JavaScript压缩：npm install hexo-uglify –save CSS压缩插件：npm install hexo-clean-css –save SEO优化：npm install hexo-generator-seo-friendly-sitemap –save References https://www.npmjs.com/package/hexo http://www.jianshu.com/p/465830080ea9 http://www.jianshu.com/p/db7e64d86067 http://www.jianshu.com/p/ecd51e8ef2fa http://www.jianshu.com/p/2640561e96f8 https://www.zhihu.com/question/29017171 https://www.zhihu.com/question/24422335 http://www.docin.com/p-732332535.html http://theme-next.iissnan.com/third-party-services.html#local-search https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud]]></content>
    </entry>

    
  
  
</search>
