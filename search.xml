<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[C++中常见的兄弟概念汇总]]></title>
      <url>%2F2016%2F11%2F23%2FC-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%84%E5%BC%9F%E6%A6%82%E5%BF%B5%E6%B1%87%E6%80%BB%2F</url>
      <content type="text"><![CDATA[这一篇，将为大家整理C++中常见的几大兄弟概念的区分，是面试的常考点。由于本人水平有限，只进行了非常粗略的归纳，如若大家有疑问建议配合google逐条细扣，go! 指针函数与函数指针这条在此前C++基础笔记中已阐述过，这里为了同一管理，现再列出。 指针函数： void *fun();即返回指针的函数。 函数指针： 用以处理参数与返回值形式均一致，而功能是不确定的一组函数，有两种声明与定义 形式一 123T (*fun)(...); //声明fun = FunctionName; //赋值fun(); //调用 e.g.: 123void (*fun)();fun = A;fun(); 形式二 123typedef T (*fun)(...);fun A = &amp;FunctionName;(*A)(...); //相当于调用FunctionName() e.g.: 123typedef void (*fun)();fun B = &amp;A; //相当于一种类型(*B)(); //即 B(); 类对象与类指针 类对象A a;，类指针A *a;； 类指针在访问成员时用：指针名-&gt;成员名访问，如：a-&gt;fun();; 类指针在使用前一定要初始化（意义同普通指针），或new或去指向对象； 类指针指向内存中存放的类对象，而类对象是利用构造函数在内存中分配一块内存； 在访问类成员时，类对象用.操作符，而类指针用-&gt;操作符； 类对象为栈变量，类指针为堆变量； 在类的声明尚未完成时，可声明类指针，不可声明类对象；（此前的“类的前向引用”章节里类似） 要发挥虚函数的作用，则必须使用类指针（同多态性）。 浅拷贝与深拷贝 是针对类的拷贝构造函数的一个子概念。 浅拷贝只是对对应数据的简单复制，这对数组、指针等需要动态分配内存的变量会造成无法估计的错误。因为两个对象指针指向了同一块内存地址，在这两个对象调用析构函数时，相当于会执行两次delete，程序会崩溃，此时便需要深拷贝； 深拷贝：在拷贝构造函数中为本类的变量申请自己的空间，使之不同对象的变量互不影响； 类的默认拷贝函数为浅拷贝，用老对象给新对象一个一个赋值。 e.g.: public、protected与private 用来定义类成员的属性； public: 只能由该类中的函数、子类函数、友元函数，以及该类的对象所访问； protected: 只能由该类中的函数、子类函数，以及友元函数访问，不能被该类的对象访问； private: 只能由该类中的函数、友元函数访问，不可以被子类或者类的对象访问； 总结： 类的对象只能访问该类的public成员； 类的内部函数、友元函数可以访问该类的所有成员； 子类函数可以访问父类的public成员与protected成员。 公有继承、私有继承与保护继承 用来描述子类对父类的继承类型，及子类对父类成员的访问权限； public继承： 父类成员对子类的可见性：public/protected可见 父类成员对子类对象的可见性：仅public可见 子类的对象可以赋值给父类的对象，如：Point B = A; 子类的对象可以初始化父类的引用，如：Point &amp;B = A; 子类对象的地址可以赋给父类类型的指针，如：Point *B = &amp;A; private继承： 父类成员对子类的可见性：public/protected可见 父类成员对子类对象的可见性：所有成员均不可见； protected继承： 同private继承。 new、operator new与placement new new是运算符，operator new()与placement new()为new的重载形式，是一个函数； operator new()完成的操作一般只是分配内存； 如MyClass *p = new MyClass;，这里new作了三步操作： 调用了operator new()函数用以分配内存； 调用了MyClass构造函数来生成类的对象； 返回了相应的指针。 operator new()在每一个类当中均可以被重载，使其完成其类特有的分配空间效果，但不能在全局上对其进行重载；而如果类中没有对其进行重载，则是调用全局的::operator new()来分配；若重载，重载的返回类型必须为void *，可以附带参数，且第一个参数为空间大小。 placement new()是重载了operator new()的一个标准、一个全局版本，其并不能分配内存；原型为void *operator new(size_t, void*)，placement new()可以解决： 缓冲区问题：如果想在预分配的内存上创建对象，则不能用new； 提高时空效率：new是在堆中找到足够大的剩余空间，此速度是很慢的，而且有可能出现无法分配内存的情况。因此placement new()不用再查找内存，分配的时间也是常数级，因为此前已经预分配完。（适用于小对象、数量又多、长时间运行且不希望被打断的程序） 三者的区别： new： 不能重载，行为总是如下执行：调用operator new()分配内存-&gt;调用其构造函数生成其类对象-&gt;返回函数指针 operator new(): 实现不同的内存分配，可以重载； 如果类没有对operator new()进行重载，则new是会调用全局的::operator new()完成堆的分配。 placement new(): 它只是operator new()重载的一个版本，并不能分配内存，只是返回指向已经分配好的某段内存的一个指针。因此要释放的时候是不能删除它的，只能通过调用对象的析构函数。 如果想在一个已经分配的内存中创建一个对象，使用new是行不通的，placement new允许在一个已经分配好的内存中构造一个新的对象，原型void *operator new(size_t size, void *p)的p即指向一个已经分配好的内存缓冲区的首地址。 e.g.:123456class Task;char *buff = new char[sizeof(Task) + sizeof(int)]; //提前分配好的一块内存Task *ptask = new (buff) Task; //在分配好的一块内存区域上构造一个对象ptask-&gt;fun(); //使用ptask-&gt;~Task(); //必须显式地调用析构函数delete [] buff; //如果不再打算使用Buff，别忘了释放它 Q: 有了new/delete为何还需要operator new()/operator delete()? A: 实现自己的operator new/delete是为了更高的效率，它们具有良好的通用性，在那些需要大量动态分配而空间却很小的对象尤为适用。 函数返回指针与返回引用 返回指针问题：T *fun(){} 123456789101112T *fun()&#123; T *temp1 = NULL; T temp2[] = "hello"; //局部变量放在栈区，函数结束后会进行释放，因此不能用来做return; temp1 = malloc(...); //动态申请的变量位于堆区，只要程序运行且不free就一直存在，所以可以用来return，但记得在外部调用完毕后执行free return temp1;&#125;/*要调用函数中的变量问题，有两种方案：1）动态分配空间的变量，new/malloc2）使用的static变量、const变量、或全局变量*/ 返回引用问题： T &amp;fun(){} 值返回会产生一个临时变量用来存储结果，而引用返回则不会，所以引用返回不能返回对局部变量的引用，因为局部变量在函数结束后会释放掉其对应的内存空间 所以可以尝试返回：函数参数的引用变量或者*this或返回左值 重载、覆盖与隐藏-&gt; 用以描述类中函数的特性； 重载overload: 参数类型、个数、顺序至少有一个不同； 只是返回类型不同的不算是overload； 重载发生在相同的范围内，即在同一个类的不同函数之间； virtual关键字可有可无。 覆盖override 函数名、参数、返回类型必须完全相同； 覆盖发生在不同的范围内，即在父类子类之间的不同函数； 父类中的函数必须含有virtual关键字。 隐藏 隐藏是指子类的函数屏蔽了与其同名的父类函数； 若子类的函数与父类的函数同名，但参数不同，无论有无virtual，父类函数将被隐藏；（注意与重载的区分） 若子类的函数与父类的函数同名，且参数相同，但父类函数中没有virtual关键字，此时父类函数将被隐藏。（注意与覆盖的区分） e.g.:1234567891011121314151617181920212223242526class Base&#123;public: virtual void f(float x); void g(float x); void h(float x);&#125;;class Derived : public Base&#123;public: virtual void f(float x); //override void g(int x); //隐藏 void h(float x); //隐藏&#125;;//case:Derived d;Base *p = &amp;d;Derived *q = &amp;d;p-&gt;f(); //Derivedq-&gt;f(); //Derivedp-&gt;g(); //Baseq-&gt;g(); //Derivedp-&gt;h(); //Baseq-&gt;h(); //Derived 堆与栈 申请方式的不同： 堆是动态分配的，由程序员自行决定new或者delete； 栈是由系统自动分配的，如声明一个函数的局部变量。 系统响应的不同： 栈：只要栈的剩余空间比所申请的空间大，系统就提供，否则就是栈溢出； 堆：操作系统在堆中有一个记录空闲地址的链表，当系统收到申请时，首先遍历该链表，寻找第一个大于所申请空间的堆结点，然后分配给程序，同时会在该空间的首地址记录此空间的大小，用在delete/free时能全部回收。（由这种工作机制可以看出，堆容易造成内存碎片） 申请大小的限制： 栈：栈是向低地址扩展的数据结构，是一块连续的内存区域，因此栈顶是事先规定好的，即容量也是规定好的，windows栈大小一般是2M，总之是个常数。 堆：堆是向高地址扩展的数据结构，是一块不连续的内存区域，因为是用链表来存储空闲的地址。堆的大小取决于计算机中有效的虚拟内存。（如我之前在博客中提过的“堆的最大申请数量——我能malloc多少？”，当然当时测试机的内存是4G） 效率的不同 栈是由操作系统自身来操作，速度快，不过无法进行人为操作； 堆由函数分配，速度慢，容易产生碎片，但使用操作方便。 malloc/free与new/delete malloc/free是函数，new/delete是关键字； malloc仅仅是个函数，用来向堆申请空间赋给变量； new可以调用对象的构造函数，delete则可以调用析构函数； free前要判断指针是否是NULL，而delete则不用； delete后的指针为游离指针，一般需要重新指向NULL。 sizeof()与strlen() sizeof返回的类型是unsigned int，strlen也是； sizeof为运算符，strlen是一个函数； strlen只能用char*为参数，而sizeof的参数可以是类型、函数等； sizeof在编译时计算，strlen在运行时才能知道； e.g.123char a[20] = "123456";//sizeof(a)值为20;//strlen(a)值为6; 宏与内联函数 宏只是简单地替换，inline是嵌入代码中，要做类型检查； inline一般只用于： 函数被不断地重复调用； 函数只有简单几行，且不含for，while，switch。 宏不是函数，只是在编译预处理阶段，将程序中有关字符串替换掉； inline必须与具体的函数定义体结合才称为内嵌函数。 指针与引用 指针可以指向空NULL，而引用在任何时候都不可以指向空值，即要初始化； 指针在使用时经常要判断是否为空指针，否则空指针的使用会出现异常； 可修改性：指针指的对象可以修改，而引用一旦初始化，则它将指向一个对象，且不可改变，但是该对象的内容是可变的。 空指针与迷途指针 当delete一个指针后，通知编译器释放内存，但指针本身依然存在，则此时即为迷途指针； 在对迷途指针执行myptr = NULL时，即变成空指针了； 对迷途指针使用delete会令程序崩溃，而delete空指针则不会； 最好的习惯是delete p;之后，再p = NULL;，不要存在迷途指针。 指针与句柄 句柄相当于指针的指针，系统用句柄来标记系统资源； 句柄是记载着对象在内存中的地址，而这个地址对应存放着实际对象。 struct与class struct默认访问变量方式为public，而class默认是private；（仅此不同） struct与class类似，也可以有构造函数、析构函数、继承等； 在c++中存在struct即是为了兼容以前的c的版本。 左值与右值 只能出现在“=”右边的叫右值（即数据值）； 既可以在左也可以在右的称为左值（即地址值）； references由于我是早些年先整理出的纸质文档，参考文献较多且当时没有标注，若构成侵权请在底下留言，我会进行删除。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++基础_0x02]]></title>
      <url>%2F2016%2F11%2F21%2FC-%E5%9F%BA%E7%A1%80-0x02%2F</url>
      <content type="text"><![CDATA[这一小节主要介绍C++中常见的几个比较重要的关键字，go const12345int b = 500;const int* a = &amp;b; //①int const* a = &amp;b; //②int* const a = &amp;b; //③const int* const a = &amp;b; //④ const位于星号的左侧，则const用以修饰指针所指向的变量为常量； const位于星号的右侧，则const用以修饰指针本身为常量； const与变量类型的位置无关。 这三点我们展开说： 式子①等价于式子②，表示指向的值不可以修改，但可以重新指别处。针对①②中的a可以先不进行初始化，因为a本身不是常量。 e.g. 12345678910111213141516int b = 500;const int* a = &amp;b; //a指向的区域是常量，不可修改*a = 600; //编译错误，a指向的是read-only区域---int b = 500;const int* a = &amp;b;b = 600;cout &lt;&lt; *a; //输出600---int b = 500, c = 600;const int* a = &amp;b;a = &amp;c; //a重新指向别的变量cout &lt;&lt; *a; //输出600 对于式子③，指针本身是常量，必须先进行初始化，本身位置是不可动的，但指向的值是可以修改的；e.g. 12345int b = 500, c = 600;int* const a = &amp;b; //正确int* const d; //错误，d为常量指针，必须进行初始化*a = 600; //正确，指向的值可以修改，此时b的值也随之变成500a++; //错误，a本身位置不可动 对于式子④，指针本身与指向的内容均为常量，均不可变。 还有一种const，在类中，成员函数后加一个const，如int GetX() const;，表明这个函数不会对类的数据成员进行修改，否则会报错。 针对const与普通函数的组合，如int const fun();(表示返回值必须为常量)，其判断同上。 extern 标识于变量或函数之前，用于表示变量或函数定义于别的文件中，提示编译器去其他编译模块寻找； extern 类型 变量名; 如： extern int a; 外部变量是可以为多个源文件所共享的全局变量； 可以于多个文件中用extern多处声明，但定义只能有一处。 extern &quot;c&quot; 函数名 由于c++支持重载，所以对函数名翻译会使之变化，使之可能在链接时找不到对应函数的情况； extern &quot;c&quot;会进行链接指定，告诉编译器要保持名称。 extern 返回值 函数名(参数列表); 提示该函数是在别的源文件里定义的。 因此，extern进行变量/函数声明，不要去跟定义，否则会极有可能在链接不同的编译模块时，出现重复定义的错误。 namespace 程序规模渐大，各coders在合并程序的时候就会可能有起名的冲突，因此引入namespace将类、函数等聚集在一个域下； e.g.12345678namespace exap&#123; int a; vodi fun()&#123;...&#125;&#125;//在调用时，使用::exap::a; static 隐藏：所有未加static的全局变量或函数都具有全局可观性。 如果是变量，记得要加extern，告诉编译器去别的文件中寻找；函数默认情况下是有的。 保持变量内容的持久： static变量在程序开始时分配空间，结束时释放空间； 存储在内存的静态数据区。（全局变量也是存储于此） tips: 关于static还有一个较为详细的记录，下回分析 volatile 首先要明白的是，编译器在编译时，会对源代码进行优化：比如第一次对i变量取值，会到其内存中去取，到第二次再遇到i变量，编译器如果识别到这两次读之间若没有对i进行修改的代码，则会直接引用上次读取的值，节省时间提高效率。但是，这在“多线程并发访问共享变量”、“内嵌汇编操纵栈”等地方，是致命的。 所以，volatile关键字告诉编译器该变量是易变的，你要随时每次都去其内存地址里取，即要求每次不使用缓存，必须去内存中取。如：volatile int i = 5; 一般需要volatile变量的地方，有： 中断服务程序中修改的供其他程序访问的变量要加volatile; 多线程多任务环境下各任务之间共享的变量加volatile; 存储器映射的硬件寄存器要加volatile，每次读写都有不同的意义。 volatile指针与const修饰的类似，只能用const_cast转换运算符来移除volatile限定符。e.g.: 123volatile int c = 5;volatile int *cons_c = &amp;c;int *modifier = const_cast&lt;int*&gt;(cons_c); volatile可以做到两件事： 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回； 阻止编译器调整操作volatile变量的指令执行顺序。 explicit 抑制隐式转换； 用来修饰类的构造函数，表明该构造函数是显式的； 介绍一个隐式转换的例子： 123456789class A &#123;public: A(int m); ...&#125;;A test = 10; //编译通过A test1 = 'a'; //编译也通过，但显然不是我们希望的，explicit便可以阻止此现象发生 因此原则上应该给所有的构造函数加上explicit； 只有在构造函数的声明中才能加explicit，不能在定义上加。 References由于我是早些年先整理出的纸质文档，参考文献较多且当时没有标注，若构成侵权请在底下留言，我会进行删除。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++基础_0x01]]></title>
      <url>%2F2016%2F11%2F19%2FC-%E5%9F%BA%E7%A1%80-0x01%2F</url>
      <content type="text"><![CDATA[OK, 接着上一节的继续。上一节整理到“类中的数据共享机制”，这节就从对共享数据的保护开始吧。 对共享数据的保护 常引用——const 类型 &amp;变量名 一般用户给函数当形参，此时该函数不能对实参进行破坏 常对象——类名 const 对象名 常对象必须进行初始化，且不能被更新； 不能访问普通成员函数，只能访问常成员函数。 常成员函数 返回值类型 函数名（参数列表） const; 只能调用该类中用const修饰的成员函数，不可更新类的成员变量； 常对象只能调用常成员函数； const可以用于区分不同重载函数。 常数据成员 任何成员函数均不可对该成员进行赋值； 构造函数对其进行初始化，只可以通过初始化列表，e.g.：A::A(int i) : a(i){} 函数指针与指针函数 指针函数： void *fun();即返回指针的函数。 函数指针： 用以处理参数与返回值形式均一致，而功能是不确定的一组函数，有两种声明与定义 形式一 123T (*fun)(...); //声明fun = FunctionName; //赋值fun(); //调用 e.g.: 123void (*fun)();fun = A;fun(); 形式二 123typedef T (*fun)(...);fun A = &amp;FunctionName;(*A)(...); //相当于调用FunctionName() e.g.: 123typedef void (*fun)();fun B = &amp;A; //相当于一种类型(*B)(); //即 B(); 条件编译指令 作用：有效地防止头文件中的变量被重复定义 12345678910111213#ifdef 标识符 ...#else ...#endif---#ifndef 标识符 ...#else ...#endif e.g.: 123456789101112131415//head.h #ifndef HEAD_H #define HEAD_H ...#endif//file1.h#include "head.h"//file2.h#include "head.h"//main.h#include "file1.h"#include "file2.h" References 由于我是早些年先整理出的纸质文档，参考文献较多且当时没有标注，若构成侵权请在底下留言，我会进行删除。今天先整这么多了，goodnight:)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++基础_0x00]]></title>
      <url>%2F2016%2F11%2F17%2FC-%E5%9F%BA%E7%A1%80-0x00%2F</url>
      <content type="text"><![CDATA[今天在网上看到有人非常耐心地对c++primer一书从第一章开始一节一节地写读书笔记，着实令我非常佩服。于是我就想着，也该是时候把平时记的一些东西归纳整理下，把它们归类存电子档起来，这样以后就不用翻阅纸质文档了。 运算符 算术运算符：* - + / 关系运算符：&lt; &gt; == != &gt;= &lt;= 逻辑运算符：&amp;&amp; || ！ 位运算符： &lt;&lt; &gt;&gt; ~ | &amp; ^ 赋值运算符：= 域运算符：:: 模运算符：% 条件运算符：? : 逗号运算符：， （e.g. a=3*5, a*4; //a为60） 指针运算符：* &amp; 求字节运算符：sizeof 强制类型转换运算符：（类型） 分量运算符：. -&gt; （应用于类、结构体中） 下标运算符：[ ] 函数调用运算符：（变量） 优先级关系 L1：( ) [ ] -&gt; . :: 右++ 右– L2：! ~ 左++ 左– - + * &amp; (type) sizeof L3：-&gt; . （e.g. ptr-&gt;*var=24; obj* var; L4：* / % L5：+ - L6：&lt;&lt; &gt;&gt; L7：&lt; &gt; &lt;= &gt;= L8：== != L9：&amp; L10：^ L11：| L12：&amp;&amp; L13：|| L14：? : L15：= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= L16：， 联合体 union 123456union Name&#123; type1 member1; type2 member2; ...&#125;; 成员具有相同的内存地址，对某个成员赋值，将会覆盖之前成员的值，使之消失。（这也是其与结构体的区别） 在任意时刻，union只能有一个成员存在值。 无名联合体通常用于结构体/类的成员。(就是没有Name的联合体) e.g. 类 Class 构造函数constructor（有默认的） 作用：对对象进行初始化，在对象被创建时由编译器自动调用。 函数名与类名相同，没有返回值。 拷贝构造函数copy constructor（有默认的） 形参为本类对象的引用，作用是用一个已存在的对象去初始化另一个新的对象，具体即为完成对象的克隆。形如：类名 (类名 &amp;对象名) 被调用的情况（条件）： 用一个对象去初始化另一个对象。 Point a(b) 某函数的形参为类的对象时，在进行形参与实参结合时。void f(Point a) 某函数的返回值为类的对象时，在返回调用的时候。Point f(int x) ps: 编译器会在调用函数处创建一个临时的无名对象，其生命周期仅存在于如Point A = f(); 此语句中。 类的成员函数 原型声明要写在类体中，而具体实现一般是要写在类之外的。返回类型 类名::函数名(参数列表) {} 内联成员函数inline 显式：在函数体实现时，在返回值的类型前加inline 隐式：直接将函数体放于类体内。 针对一些功能简单、规模较小、使用频繁的函数，可以设计为内联函数，它会在程序的编译时期将函数体放到每一个调用处。 inline只表示对编译器发出一个请求，但编译器并不一定承诺将其作为内联，同时，没有用inline修饰的函数也可能被编译成内联。 析构函数destructor (有默认的) 在对象的生存期即将结束时被自动调用，不接受任何参数~类名(){} 类的组合 各类的构造函数调用次序： 1）先调用内嵌对象的构造函数，如果内嵌了多个类，则按它们在类中定义的顺序来调用； 2）再调用本类的构造函数。 析构函数的调用顺序则与构造函数完全相反。 组合类构造函数定义的一般形式： 类名::类名(形参表):内嵌对象1(形参表), 内嵌对象2(形参表)... {} 此构造函数组合类初始化方法可应用于一般变量，如Circle::Circle(float r) : R(r){} 为组合类编写拷贝构造函数时，需要为内嵌成员对象传递参数。 类的前向引用声明 类的组合可能会相互依赖，此时便需要前向引用声明，否则编译不会通过，但可以声明指针，不能是对象。123class B;class A&#123;void f(B b)&#125;; //声明了对象，则必须前向声明class B&#123;void g(A a)&#125;; 类中的数据共享机制 类的静态成员-&gt; 解决同一个类不同对象之间数据与函数共享问题。 静态数据成员 一个类的所有对象只有一份拷贝； 通过类名::属性名来访问，在所有函数外部进行初始化。 静态函数成员 可以直接访问该类的静态数据和函数成员； 如果要访问非静态数据成员，则必须进行参数传递来得到对象，再由对象来访问； 非静态函数也可以访问静态成员，但需要用非内联函数，同时函数体要与静态成员处于同一个源文件中。 友元 friend-&gt; 不同类的成员函数之间或成员函数与普通函数之间的数据共享机制 友元函数 在类中用friend修饰的非成员函数；（该函数在类外的实现不必加friend 友元函数可以是另一个类的成员函数； 可以访问该类的private, protected成员； 通过类的对象来访问对象成员 友元类 12345class B&#123; friend class A; ...&#125;; A的所有成员函数均为B的友元函数，可以访问B类的所有成员； 友元关系不能传递、继承，同时是单向的。 References 由于我是早些年先整理出的纸质文档，参考文献较多且当时没有标注，若构成侵权请在底下留言，我会进行删除。今天先整这么多了，goodnight:)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用GTK+写点儿界面]]></title>
      <url>%2F2016%2F11%2F17%2F%E7%94%A8GTK-%E5%86%99%E7%82%B9%E5%84%BF%E7%95%8C%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[最近需要在ubuntu上写一个界面，找了一圈还是用GTK+来写吧，毕竟跟C语系是同宗的，结合起来比较顺手。这里列一些常用的API吧。12345678gtk_init(&amp;argc, &amp;argv);window = gtk_window_new(GTK_WINDOW_TOPLEVEL);gtk_window_set_title(GTK_WINDOW(window), "xxx"); //titlegtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER); //set centergtk_widget_set_usize(GTK_WIDGET(window), x, y); //大小gtk_window_set_resizable(GTK_WINDOW(window), FALSE); //固定界面大小，不能拖拽g_signal_connect(要处理的部件, "动作", G_CALLBACK(要响应的部件), (gpointer)参数部件可null);//如果“要处理的部件”对应多个“要响应的部件”，则直接添加多个g_signal_connect函数即可 额，又水了一篇，下次尽量整干点的~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[来点儿闲话]]></title>
      <url>%2F2016%2F11%2F17%2F%E6%9D%A5%E7%82%B9%E5%84%BF%E9%97%B2%E8%AF%9D%2F</url>
      <content type="text"><![CDATA[今年双十一没买东西，因为要毕业了，本来东西就很多带不走了，不想再添置了。然后前两天给自己买了这个域名，果然还是搞IT的么，哈哈。域名买来后就各种折腾啊，自己在这块儿之前没经验，很菜，慢慢地可算按照网上的前辈步子逐步把它给搞定了。搞了google与百度的收录，google很快一天内就好了，果然对个人站点很友好。百度的话，嗯。因为github屏蔽了baiducrawler，而且对国内网络不是很友好，所以我又把这个站点同步到coding。然后站点的baidusitemap生成的地址又是github的，这个就比较尴尬了，这问题还是先搁着吧，反正baidu还没给我收录。 感觉买了域名后，更加坚定写博客的心吧，之前在csdn上一直断断续续的，这个不好得改。关于写博客我就不再强行安利了，如人饮水冷暖自知，甭管有没有人看，于我而言主要还可以自己查阅之前遇到的坑，好习惯得坚持，对吧：）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql-proxy installation]]></title>
      <url>%2F2016%2F11%2F10%2Fmysql-proxy-installation%2F</url>
      <content type="text"><![CDATA[os: ubuntu 13.04 amd64 1) install the lua env.1sudo apt-get install liblua5.1-0-dev 2) install the mysql-proxy1sudo apt-get install mysql-proxy 3) start mysql-proxy1mysql-proxy --proxy-address=your_ip:your_port --proxy-backend-addresses=your_mysql_server_addresses --proxy-lua-script=/usr/share/mysql-proxy/rw-splitting.lua --admin-username=your_name --admin-password=your_password --admin-lua-script=/usr/share/mysql-proxy/admin.lua ========== update: 今天仓促地post了这篇，然后我的站点就挂掉了，不清楚是什么问题，调了几个小时依旧不能解决，考虑到之前博文有备份，索性rebuild了整个bog，我这种解法也是蛮暴力的+_+]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ubuntu低版本更新源]]></title>
      <url>%2F2016%2F11%2F02%2FUbuntu%E4%BD%8E%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E6%BA%90%2F</url>
      <content type="text"><![CDATA[由于很多原型系统都是在低版本的linux上研发的，所以经常需要用到这些老古董，但是很多源都已经不支持在线安装和更新了，因此google到了一份支持老版本的更新源，备份下。 12345678910111213141516/etc/apt/sources.listdeb http://old-releases.ubuntu.com/ubuntu/ raring main universe restricted multiversedeb-src http://old-releases.ubuntu.com/ubuntu/ raring main universe restricted multiversedeb http://old-releases.ubuntu.com/ubuntu/ raring-security main universe restricted multiversedeb-src http://old-releases.ubuntu.com/ubuntu/ raring-security main universe restricted multiversedeb http://old-releases.ubuntu.com/ubuntu/ raring-updates main universe restricted multiversedeb-src http://old-releases.ubuntu.com/ubuntu/ raring-updates main universe restricted multiversedeb http://old-releases.ubuntu.com/ubuntu/ raring-backports main restricted universe multiversedeb-src http://old-releases.ubuntu.com/ubuntu/ raring-backports main restricted universe multiversedeb http://old-releases.ubuntu.com/ubuntu/ raring-proposed main restricted universe multiversedeb-src http://old-releases.ubuntu.com/ubuntu/ raring-proposed main restricted universe multiverse]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello Blogs]]></title>
      <url>%2F2016%2F09%2F15%2FHello-Blogs%2F</url>
      <content type="text"><![CDATA[Hexo+github博客搭建成功，以后就往这里发博文了^_^，开博先来一篇搭建的过程，记录下方便以后查阅。PS：之前的博客地址是http://blog.csdn.net/scanf5288 工具 node.js git github账户 duoshuo账户 macOS 安装Hexohexo是一个基于node.js的简便、功能强劲的博客框架。Nodejs的安装是傻瓜式地点下一步即可。安装后，其包管理器npm也会一并安好。 1）打开terminal，键入命令1sudo npm install -g hexo-cli --no-optional 2）选择在自己方便管理的地方，创建博客的根目录文件夹，如我是在~/Documents/下创建了一个Blog的文件夹，统一管理。 3）进入根目录，执行两条命令hexo init与npm install 至此，hexo已安装完毕，这样我们就已经可以再本地写博文了。 关联GitHub Pages接下来我们的工作是把本地的博文部署到gitpage上，以供他人阅览，总不能自己写的博客仅给自己看吧^_^ 本节的首要前提是你的电脑需要有自己仓库的push权限，权限的配置只需到github个人设置里添加本机的ssh key即可，这个网上有很多教程就不进行赘述了。 1）先在github上new一个仓库，仓库名必须是“github账户名.github.io”。以后它就是你个人博客的地址了。 2）安装git部署插件，执行1npm install hexo-deployer-git --save 3）配置根目录下的站点配置文件_config.yml。在文件的下方，修改1234deploy: type: git repo: https://github.com/yourgithub/yourgithub.github.io.git branch: master 注意需要有branch属性，有的教程里面说不需要，但经过我自己实践是需要的。至此，关联gitpage完毕。 关于部署部署之前，肯定先是准备自己的博文，执行1hexo new "article_name" 就会在/source/_posts/下生成article_name.md文件，支持MarkDown语法，然后就可以欢快地进行书写了。 在真正部署之前，我一般喜欢在本地预览下效果，执行12hexo g //hexo generate 生成页面hexo s //hexo server 本地服务器启动 然后打开浏览器输入localhost:4000即可访问。 到了真正部署就容易了，执行1hexo d //hexo deploy 部署页面 随后浏览 https://yourgithub.github.io 即可，以后它就是你的站点了。当然它只是个二级域名，你还可以购买自己的域名，这样就更利于博客的推广了：） 还有一条hexo clean，我一般是在执行修改themes等较大变动时执行的，注意是在hexo g与hexo d之前。 关于主题themes本博客是用的NexT主题，简洁大方，安装很容易，在博客根目录下 1）先clone next的主题1git clone https://github.com/iissnan/hexo-theme-next themes/next 2）修改站点配置文件_config.yml。找到theme:属性，修改为next即可。 duoshuo评论模块有了博文，自然需要评论区好让看客发言，本博客采用的是多说评论系统，关联新浪微博。 1）登录duoshuo官网，创建站点，记住自己的域名信息。 2）修改主题文件夹下的配置文件/themes/next/_config.yml，注意不是站点配置文件！修改：12# Duoshuo ShortNameduoshuo_shortname: yourduoshuo 3）最后hexo g和hexo d就行了。 关于更多评论区的设置，上duoshuo官网个人页面管理里就有了。 文章分享功能当我们有了duoshuo账户后，只需要一句配置就可以开启分享功能了~修改主题配置文件/themes/next/_config.yml的duoshuo_share12# Shareduoshuo_share: true 站内搜索1）安装hexo-generator-searchdb插件，在博客根目录下执行1npm install hexo-generator-searchdb --save 2）修改站点的配置文件_config.yml，新增search项：12345search: path: search.xml field: post format: html limit: 10000 文章阅读量统计这里用的是LearnCloud，配置过程参考链接10已经描述的非常清楚了，相信诸君能看懂。 插件推荐这个是看网上前人推荐的，个人感觉挺好用的： 支持RSS：npm install hexo-generator-feed –save 生成站点地图：npm install hexo-generator-sitemap –save 生成百度站点地图：npm install hexo-generator-baidu-sitemap –save HTML压缩：npm install hexo-html-minifier –save JavaScript压缩：npm install hexo-uglify –save CSS压缩插件：npm install hexo-clean-css –save SEO优化：npm install hexo-generator-seo-friendly-sitemap –save References https://www.npmjs.com/package/hexo http://www.jianshu.com/p/465830080ea9 http://www.jianshu.com/p/db7e64d86067 http://www.jianshu.com/p/ecd51e8ef2fa http://www.jianshu.com/p/2640561e96f8 https://www.zhihu.com/question/29017171 https://www.zhihu.com/question/24422335 http://www.docin.com/p-732332535.html http://theme-next.iissnan.com/third-party-services.html#local-search https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud]]></content>
    </entry>

    
  
  
</search>
